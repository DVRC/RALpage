#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 18)."
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'postscript/fonts/Times/italic.r' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'postscript/fonts/Times/italic.r'\"
else
echo shar: Extracting \"'postscript/fonts/Times/italic.r'\" \(10938 characters\)
sed "s/^X//" >'postscript/fonts/Times/italic.r' <<'END_OF_FILE'
XCharStrings
X/a<D03B
X4E42
X4D46
X4D48
X4E49
X5149
X5347
X5445
XD13B
X4F42
X4E46
X4E48
X4F49
XCE42
X4E3F
X4D3C
X4B3B
X493B
X463C
X443F
X4342
X4345
X4447
X4548
X4749
X4949
X4B48
X4D45
X4E42
XC93B
X473C
X453F
X4442
X4446
X4548
X>
Xput
XMetrics
X/a[-3
X21]
Xput
XCharStrings
X/b<C834
X4441
X4444
X4547
X4648
XC934
X4541
XC541
X463E
X483C
X4A3B
X4C3B
X4E3C
X4F3D
X503F
X5042
X4F45
X4D48
X4A49
X4849
X4648
X4545
X4541
XCE3C
X4F3E
X4F42
X4E45
X4C48
X4A49
XC534
X4934
X>
Xput
XMetrics
X/b[2
X19]
Xput
XCharStrings
X/c<CE3E
X4E3F
X4F3F
X4F3E
X4E3C
X4C3B
X493B
X463C
X443F
X4342
X4345
X4447
X4548
X4749
X4949
X4C48
X4E45
XC93B
X473C
X453F
X4442
X4446
X4548
X>
Xput
XMetrics
X/c[-3
X18]
Xput
XCharStrings
X/d<D234
X4E42
X4D46
X4D48
X4E49
X5149
X5347
X5445
XD334
X4F42
X4E46
X4E48
X4F49
XCE42
X4E3F
X4D3C
X4B3B
X493B
X463C
X443F
X4342
X4345
X4447
X4548
X4749
X4949
X4B48
X4D45
X4E42
XC93B
X473C
X453F
X4442
X4446
X4548
XCF34
X5334
X>
Xput
XMetrics
X/d[2
X21]
Xput
XCharStrings
X/e<C444
X4843
X4B42
X4E40
X4F3E
X4E3C
X4C3B
X493B
X463C
X443F
X4342
X4345
X4447
X4548
X4749
X4949
X4C48
X4E46
XC93B
X473C
X453F
X4442
X4446
X4548
X>
Xput
XMetrics
X/e[-3
X18]
Xput
XCharStrings
X/f<CF35
X4E36
X4F37
X5036
X5035
X4F34
X4D34
X4B35
X4A36
X4938
X483B
X4549
X444D
X434F
XCD34
X4B36
X4A38
X493C
X4745
X4649
X454C
X444E
X434F
X4150
X3F50
X3E4F
X3E4E
X3F4D
X404E
X3F4F
XC43B
X4E3B
X>
Xput
XMetrics
X/f[5
X15]
Xput
XCharStrings
X/g<D13B
X4D49
X4C4C
X4A4F
X4750
X4450
X424F
X414E
X414D
X424C
X434D
X424E
XD03B
X4C49
X4B4C
X494F
X4750
XCE42
X4E3F
X4D3C
X4B3B
X493B
X463C
X443F
X4342
X4345
X4447
X4548
X4749
X4949
X4B48
X4D45
X4E42
XC93B
X473C
X453F
X4442
X4446
X4548
X>
Xput
XMetrics
X/g[-1
X20]
Xput
XCharStrings
X/h<C834
X4249
XC934
X4349
XC542
X473E
X493C
X4B3B
X4D3B
X4F3C
X503D
X503F
X4E45
X4E48
X4F49
XCD3B
X4F3D
X4F3F
X4D45
X4D48
X4E49
X5149
X5347
X5445
XC534
X4934
X>
Xput
XMetrics
X/h[2
X21]
Xput
XCharStrings
X/i<C934
X4835
X4936
X4A35
X4934
XC13F
X423D
X443B
X473B
X483C
X483F
X4645
X4648
X4749
XC63B
X473C
X473F
X4545
X4548
X4649
X4949
X4B47
X4C45
X>
Xput
XMetrics
X/i[6
X13]
Xput
XCharStrings
X/j<CA34
X4935
X4A36
X4B35
X4A34
XC23F
X433D
X453B
X483B
X493C
X493F
X4649
X454C
X444E
X434F
X4150
X3F50
X3E4F
X3E4E
X3F4D
X404E
X3F4F
XC73B
X483C
X483F
X4549
X444C
X434E
X4150
X>
Xput
XMetrics
X/j[6
X13]
Xput
XCharStrings
X/k<C834
X4249
XC934
X4349
XD03C
X4F3D
X503E
X513D
X513C
X503B
X4F3B
X4D3C
X4940
X4741
X4541
XC741
X4942
X4B48
X4C49
XC741
X4842
X4A48
X4B49
X4D49
X4F48
X5145
XC534
X4934
X>
Xput
XMetrics
X/k[2
X20]
Xput
XCharStrings
X/l<C834
X4442
X4346
X4348
X4449
X4749
X4947
X4A45
XC934
X4542
X4446
X4448
X4549
XC534
X4934
X>
Xput
XMetrics
X/l[7
X12]
Xput
XCharStrings
X/m<C13F
X423D
X443B
X473B
X483C
X483E
X4742
X4549
XC63B
X473C
X473E
X4642
X4449
XC742
X493E
X4B3C
X4D3B
X4F3B
X513C
X523D
X523F
X4F49
XCF3B
X513D
X513F
X4E49
XD142
X533E
X553C
X573B
X593B
X5B3C
X5C3D
X5C3F
X5A45
X5A48
X5B49
XD93B
X5B3D
X5B3F
X5945
X5948
X5A49
X5D49
X5F47
X6045
X>
Xput
XMetrics
X/m[-1
X33]
Xput
XCharStrings
X/n<C13F
X423D
X443B
X473B
X483C
X483E
X4742
X4549
XC63B
X473C
X473E
X4642
X4449
XC742
X493E
X4B3C
X4D3B
X4F3B
X513C
X523D
X523F
X5045
X5048
X5149
XCF3B
X513D
X513F
X4F45
X4F48
X5049
X5349
X5547
X5645
X>
Xput
XMetrics
X/n[-1
X23]
Xput
XCharStrings
X/o<C93B
X463C
X443F
X4342
X4345
X4447
X4548
X4749
X4949
X4C48
X4E45
X4F42
X4F3F
X4E3D
X4D3C
X4B3B
X493B
XC93B
X473C
X453F
X4442
X4446
X4548
XC949
X4B48
X4D45
X4E42
X4E3E
X4D3C
X>
Xput
XMetrics
X/o[-3
X18]
Xput
XCharStrings
X/p<C13F
X423D
X443B
X473B
X483C
X483E
X4742
X4350
XC63B
X473C
X473E
X4642
X4250
XC742
X483F
X4A3C
X4C3B
X4E3B
X503C
X513D
X523F
X5242
X5145
X4F48
X4C49
X4A49
X4848
X4745
X4742
XD03C
X513E
X5142
X5045
X4E48
X4C49
XBF50
X4650
X>
Xput
XMetrics
X/p[1
X21]
Xput
XCharStrings
X/q<D03B
X4A50
XD13B
X4B50
XCE42
X4E3F
X4D3C
X4B3B
X493B
X463C
X443F
X4342
X4345
X4447
X4548
X4749
X4949
X4B48
X4D45
X4E42
XC93B
X473C
X453F
X4442
X4446
X4548
XC750
X4E50
X>
Xput
XMetrics
X/q[-3
X20]
Xput
XCharStrings
X/r<C13F
X423D
X443B
X473B
X483C
X483E
X4742
X4549
XC63B
X473C
X473E
X4642
X4449
XC742
X493E
X4B3C
X4D3B
X4F3B
X503C
X503D
X4F3E
X4E3D
X4F3C
X>
Xput
XMetrics
X/r[-1
X17]
Xput
XCharStrings
X/s<CE3D
X4E3E
X4F3E
X4F3D
X4E3C
X4B3B
X483B
X453C
X443D
X443F
X4540
X4C44
X4D45
XC43E
X453F
X4C43
X4D44
X4D47
X4C48
X4949
X4649
X4348
X4247
X4246
X4346
X4347
X>
Xput
XMetrics
X/s[-2
X17]
Xput
XCharStrings
X/t<C934
X4542
X4446
X4448
X4549
X4849
X4A47
X4B45
XCA34
X4642
X4546
X4548
X4649
XC33B
X4C3B
X>
Xput
XMetrics
X/t[5
X14]
Xput
XCharStrings
X/u<C13F
X423D
X443B
X473B
X483C
X483F
X4645
X4647
X4849
XC63B
X473C
X473F
X4545
X4547
X4648
X4849
X4A49
X4C48
X4E46
X5042
XD23B
X5042
X4F46
X4F48
X5049
X5349
X5547
X5645
XD33B
X5142
X5046
X5048
X5149
X>
Xput
XMetrics
X/u[-1
X23]
Xput
XCharStrings
X/v<C13F
X423D
X443B
X473B
X483C
X483F
X4645
X4647
X4849
XC63B
X473C
X473F
X4545
X4547
X4648
X4849
X4949
X4C48
X4E46
X5043
X513F
X513B
X503B
X513D
X>
Xput
XMetrics
X/v[-1
X20]
Xput
XCharStrings
X/w<C13F
X423D
X443B
X473B
X483C
X483F
X4645
X4647
X4849
XC63B
X473C
X473F
X4545
X4547
X4648
X4849
X4A49
X4C48
X4E46
X4F44
XD13B
X4F44
X4F47
X5048
X5249
X5449
X5648
X5846
X5944
X5A40
X5A3B
X593B
X5A3D
XD23B
X5044
X5047
X5249
X>
Xput
XMetrics
X/w[-1
X29]
Xput
XCharStrings
X/x<C33F
X453C
X473B
X4A3B
X4B3D
X4B40
XC93B
X4A3D
X4A40
X4944
X4846
X4648
X4449
X4349
X4248
X4247
X4346
X4447
X4348
XC944
X4947
X4A49
X4D49
X4F48
X5145
XD13C
X503D
X513E
X523D
X523C
X513B
X503B
X4E3C
X4C3E
X4B40
X4A44
X4A47
X4B49
X>
Xput
XMetrics
X/x[-2
X20]
Xput
XCharStrings
X/y<C13F
X423D
X443B
X473B
X483C
X483F
X4645
X4647
X4849
XC63B
X473C
X473F
X4545
X4547
X4648
X4849
X4A49
X4C48
X4E46
X5042
XD33B
X4F49
X4E4C
X4C4F
X4950
X4650
X444F
X434E
X434D
X444C
X454D
X444E
XD23B
X4E49
X4D4C
X4B4F
X4950
X>
Xput
XMetrics
X/y[-1
X21]
Xput
XCharStrings
X/z<D13B
X503D
X4E3F
X4645
X4447
X4349
XC43F
X453D
X473B
X4A3B
X4E3D
XC53D
X473C
X4A3C
X4E3D
X503D
XC447
X4647
X4A48
X4D48
X4F47
XC647
X4A49
X4D49
X4F47
X5045
X>
Xput
XMetrics
X/z[-3
X20]
Xput
XCharStrings
X/A<CD34
X4049
XCD34
X4E49
XCC36
X4D49
XC443
X4D43
XBE49
X4449
XCA49
X5049
X>
Xput
XMetrics
X/A[2
X20]
Xput
XCharStrings
X/B<C934
X4349
XCA34
X4449
XC634
X5134
X5435
X5537
X5539
X543C
X533D
X503E
XD134
X5335
X5437
X5439
X533C
X523D
X503E
XC73E
X503E
X523F
X5341
X5343
X5246
X5048
X4C49
X4049
XD03E
X513F
X5241
X5243
X5146
X4F48
X4C49
X>
Xput
XMetrics
X/B[0
X24]
Xput
XCharStrings
X/C<D236
X5336
X5434
X533A
X5338
X5236
X5135
X4F34
X4C34
X4935
X4737
X453A
X443D
X4341
X4344
X4447
X4548
X4849
X4B49
X4D48
X4F46
X5044
XCC34
X4A35
X4837
X463A
X453D
X4441
X4444
X4547
X4648
X4849
X>
Xput
XMetrics
X/C[2
X21]
Xput
XCharStrings
X/D<C934
X4349
XCA34
X4449
XC634
X4F34
X5235
X5336
X5439
X543D
X5341
X5145
X4F47
X4D48
X4949
X4049
XCF34
X5135
X5236
X5339
X533D
X5241
X5045
X4E47
X4C48
X4949
X>
Xput
XMetrics
X/D[0
X23]
Xput
XCharStrings
X/E<C934
X4349
XCA34
X4449
XCE3A
X4C42
XC634
X5534
X543A
X5434
XC73E
X4D3E
XC049
X4F49
X5144
X4E49
X>
Xput
XMetrics
X/E[0
X23]
Xput
XCharStrings
X/F<C934
X4349
XCA34
X4449
XCE3A
X4C42
XC634
X5534
X543A
X5434
XC73E
X4D3E
XC049
X4749
X>
Xput
XMetrics
X/F[0
X22]
Xput
XCharStrings
X/G<D236
X5336
X5434
X533A
X5338
X5236
X5135
X4F34
X4C34
X4935
X4737
X453A
X443D
X4341
X4344
X4447
X4548
X4849
X4A49
X4D48
X4F46
X5142
XCC34
X4A35
X4837
X463A
X453D
X4441
X4444
X4547
X4648
X4849
XCA49
X4C48
X4E46
X5042
XCD42
X5442
X>
Xput
XMetrics
X/G[2
X22]
Xput
XCharStrings
X/H<C934
X4349
XCA34
X4449
XD634
X5049
XD734
X5149
XC634
X4D34
XD334
X5A34
XC73E
X533E
XC049
X4749
XCD49
X5449
X>
Xput
XMetrics
X/H[0
X26]
Xput
XCharStrings
X/I<C934
X4349
XCA34
X4449
XC634
X4D34
XC049
X4749
X>
Xput
XMetrics
X/I[6
X13]
Xput
XCharStrings
X/J<CF34
X4A45
X4947
X4848
X4649
X4449
X4248
X4146
X4144
X4243
X4344
X4245
XCE34
X4945
X4847
X4649
XCB34
X5234
X>
Xput
XMetrics
X/J[3
X18]
Xput
XCharStrings
X/K<C934
X4349
XCA34
X4449
XD734
X4641
XCD3D
X5149
XCC3D
X5049
XC634
X4D34
XD334
X5934
XC049
X4749
XCD49
X5349
X>
Xput
XMetrics
X/K[0
X23]
Xput
XCharStrings
X/L<C934
X4349
XCA34
X4449
XC634
X4D34
XC049
X4F49
X5143
X4E49
X>
Xput
XMetrics
X/L[2
X20]
Xput
XCharStrings
X/M<C934
X4349
XC934
X4A49
XCA34
X4B47
XD734
X4A49
XD734
X5149
XD834
X5249
XC634
X4A34
XD734
X5B34
XC049
X4649
XCE49
X5549
X>
Xput
XMetrics
X/M[0
X27]
Xput
XCharStrings
X/N<C934
X4349
XC934
X5046
XC937
X5049
XD634
X5049
XC634
X4934
XD334
X5934
XC049
X4649
X>
Xput
XMetrics
X/N[0
X25]
Xput
XCharStrings
X/O<CC34
X4935
X4737
X453A
X443D
X4341
X4344
X4447
X4548
X4749
X4A49
X4D48
X4F46
X5143
X5240
X533C
X5339
X5236
X5135
X4F34
X4C34
XCC34
X4A35
X4837
X463A
X453D
X4441
X4444
X4547
X4749
XCA49
X4C48
X4E46
X5043
X5140
X523C
X5239
X5136
X4F34
X>
Xput
XMetrics
X/O[1
X22]
Xput
XCharStrings
X/P<C934
X4349
XCA34
X4449
XC634
X5234
X5535
X5637
X5639
X553C
X533E
X4F3F
X473F
XD234
X5435
X5537
X5539
X543C
X523E
X4F3F
XC049
X4749
X>
Xput
XMetrics
X/P[0
X23]
Xput
XCharStrings
X/Q<CC34
X4935
X4737
X453A
X443D
X4341
X4344
X4447
X4548
X4749
X4A49
X4D48
X4F46
X5143
X5240
X533C
X5339
X5236
X5135
X4F34
X4C34
XCC34
X4A35
X4837
X463A
X453D
X4441
X4444
X4547
X4749
XCA49
X4C48
X4E46
X5043
X5140
X523C
X5239
X5136
X4F34
XC547
X4546
X4644
X4843
X4943
X4B44
X4C46
X4C4D
X4D4E
X4F4E
X504C
X504B
XCC46
X4D4C
X4E4D
X4F4D
X504C
X>
Xput
XMetrics
X/Q[1
X22]
Xput
XCharStrings
X/R<C934
X4349
XCA34
X4449
XC634
X5134
X5435
X5537
X5539
X543C
X533D
X503E
X473E
XD134
X5335
X5437
X5439
X533C
X523D
X503E
XCC3E
X4E3F
X4F40
X5048
X5149
X5349
X5447
X5446
XCF40
X5147
X5248
X5348
X5447
XC049
X4749
X>
Xput
XMetrics
X/R[0
X24]
Xput
XCharStrings
X/S<D336
X5436
X5534
X543A
X5438
X5336
X5235
X4F34
X4B34
X4835
X4637
X4639
X473B
X483C
X4F40
X5142
XC639
X483B
X4F3F
X5040
X5142
X5145
X5047
X4F48
X4C49
X4849
X4548
X4447
X4345
X4343
X4249
X4347
X4447
X>
Xput
XMetrics
X/S[1
X23]
Xput
XCharStrings
X/T<CD34
X4749
XCE34
X4849
XC734
X443A
X4634
X5534
X543A
X5434
XC449
X4B49
X>
Xput
XMetrics
X/T[2
X21]
Xput
XCharStrings
X/U<C834
X453F
X4443
X4446
X4548
X4849
X4C49
X4F48
X5146
X5243
X5634
XC934
X463F
X4543
X4546
X4648
X4849
XC534
X4C34
XD334
X5934
X>
Xput
XMetrics
X/U[0
X25]
Xput
XCharStrings
X/V<C634
X4749
XC734
X4847
XD434
X4749
XC434
X4A34
XD034
X5634
X>
Xput
XMetrics
X/V[2
X20]
Xput
XCharStrings
X/W<C834
X4649
XC934
X4747
XD034
X4649
XD034
X4E49
XD134
X4F47
XD834
X4E49
XC534
X4C34
XD534
X5B34
X>
Xput
XMetrics
X/W[-1
X26]
Xput
XCharStrings
X/X<C734
X4E49
XC834
X4F49
XD534
X4149
XC534
X4B34
XD134
X5734
XBF49
X4549
XCB49
X5149
X>
Xput
XMetrics
X/X[1
X22]
Xput
XCharStrings
X/Y<C634
X4A3E
X4749
XC734
X4B3E
X4849
XD534
X4B3E
XC434
X4A34
XD134
X5734
XC449
X4B49
X>
Xput
XMetrics
X/Y[2
X21]
Xput
XCharStrings
X/Z<D434
X4149
XD534
X4249
XC834
X453A
X4734
X5534
XC149
X4F49
X5143
X4E49
X>
Xput
XMetrics
X/Z[1
X22]
Xput
XCharStrings
X/ff
X<D435
X5336
X5437
X5536
X5435
X5234
X4F34
X4C35
X4A37
X4939
X483C
X4740
X4549
X444D
X434F
XCF34
X4D35
X4B37
X4A39
X493C
X4745
X4649
X454C
X444E
X434F
X4150
X3F50
X3E4F
X3E4E
X3F4D
X404E
X3F4F
XDA35
X5936
X5A37
X5B36
X5B35
X5A34
X5834
X5635
X5536
X5438
X533B
X5049
X4F4D
X4E4F
XD834
X5636
X5538
X543C
X5245
X5149
X504C
X4F4E
X4E4F
X4C50
X4A50
X494F
X494E
X4A4D
X4B4E
X4A4F
XC43B
X593B
X>
Xput
XMetrics
X/ff
X[2
X26]
Xput
XCharStrings
X/fi
X<D535
X5436
X5537
X5636
X5535
X5234
X4F34
X4C35
X4A37
X4939
X483C
X4740
X4549
X444D
X434F
XCF34
X4D35
X4B37
X4A39
X493C
X4745
X4649
X454C
X444E
X434F
X4150
X3F50
X3E4F
X3E4E
X3F4D
X404E
X3F4F
XD33B
X5142
X5046
X5048
X5149
X5449
X5647
X5745
XD43B
X5242
X5146
X5148
X5249
XC43B
X543B
X>
Xput
XMetrics
X/fi
X[2
X24]
Xput
XCharStrings
X/fl
X<D335
X5236
X5337
X5436
X5435
X5234
XD634
X4F34
X4C35
X4A37
X4939
X483C
X4740
X4549
X444D
X434F
XCF34
X4D35
X4B37
X4A39
X493C
X4745
X4649
X454C
X444E
X434F
X4150
X3F50
X3E4F
X3E4E
X3F4D
X404E
X3F4F
XD534
X5142
X5046
X5048
X5149
X5449
X5647
X5745
XD634
X5242
X5146
X5148
X5249
XC43B
X533B
X>
Xput
XMetrics
X/fl
X[2
X24]
Xput
XCharStrings
X/ffi
X<D435
X5336
X5437
X5536
X5435
X5234
X4F34
X4C35
X4A37
X4939
X483C
X4740
X4549
X444D
X434F
XCF34
X4D35
X4B37
X4A39
X493C
X4745
X4649
X454C
X444E
X434F
X4150
X3F50
X3E4F
X3E4E
X3F4D
X404E
X3F4F
XE035
X5F36
X6037
X6136
X6035
X5D34
X5A34
X5735
X5537
X5439
X533C
X5240
X5049
X4F4D
X4E4F
XDA34
X5835
X5637
X5539
X543C
X5245
X5149
X504C
X4F4E
X4E4F
X4C50
X4A50
X494F
X494E
X4A4D
X4B4E
X4A4F
XDE3B
X5C42
X5B46
X5B48
X5C49
X5F49
X6147
X6245
XDF3B
X5D42
X5C46
X5C48
X5D49
XC43B
X5F3B
X>
Xput
XMetrics
X/ffi
X[2
X35]
Xput
XCharStrings
X/ffl
X<D435
X5336
X5437
X5536
X5435
X5234
X4F34
X4C35
X4A37
X4939
X483C
X4740
X4549
X444D
X434F
XCF34
X4D35
X4B37
X4A39
X493C
X4745
X4649
X454C
X444E
X434F
X4150
X3F50
X3E4F
X3E4E
X3F4D
X404E
X3F4F
XDE35
X5D36
X5E37
X5F36
X5F35
X5D34
XE134
X5A34
X5735
X5537
X5439
X533C
X5240
X5049
X4F4D
X4E4F
XDA34
X5835
X5637
X5539
X543C
X5245
X5149
X504C
X4F4E
X4E4F
X4C50
X4A50
X494F
X494E
X4A4D
X4B4E
X4A4F
XE034
X5C42
X5B46
X5B48
X5C49
X5F49
X6147
X6245
XE134
X5D42
X5C46
X5C48
X5D49
XC43B
X5E3B
X>
Xput
XMetrics
X/ffl
X[2
X35]
Xput
XCharStrings
X/dotlessi
X<C13F
X423D
X443B
X473B
X483C
X483F
X4645
X4648
X4749
XC63B
X473C
X473F
X4545
X4548
X4649
X4949
X4B47
X4C45
X>
Xput
XMetrics
X/dotlessi
X[-1
X13]
Xput
XCharStrings
X/space
X<8000
X8563C
X4400
X008D7
X3848
X>
Xput
XMetrics
X/space
X[64
X0]
Xput
END_OF_FILE
if test 10938 -ne `wc -c <'postscript/fonts/Times/italic.r'`; then
    echo shar: \"'postscript/fonts/Times/italic.r'\" unpacked with wrong size!
fi
# end of 'postscript/fonts/Times/italic.r'
fi
if test -f 'source/hard-interface.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/hard-interface.c'\"
else
echo shar: Extracting \"'source/hard-interface.c'\" \(10584 characters\)
sed "s/^X//" >'source/hard-interface.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X#include "graphics.h"
X
Xstruct hardware
X {
X 	/*
X 	 * Each driver is expected to provide its own definition of this structure.
X 	 * It is only ever used as a pointer and is never dereferenced outside the driver.
X 	 */
X 	int pad;
X };
X
X/*
X *	This file describes the interface that PostScript requires to the graphics system at Version 1.4.
X *	
X *	''Hardware'' in this context refers to a pointer to windows and/or bitmaps and is the lowest level
X *	of access that PostScript is interested in. Any Hardware parameter may be expected to be NULL.
X */
X
X/*********************************** CREATION OF WINDOWS AND BITMAPS *******************/
X
Xstruct hardware *InitHardware () {}
X/*
X *	InitHardware () returns a default device which PostScript may use immediately (or NULL if not appropriate).
X *	Its size and shape are not defined. Most typically the user will want to start up another device
X *	before it is used anyway. No attempt will be made by PostScript to Destroy the resulting
X *	device.
X */
X
Xstruct hardware *NewBitmapHardware (width, height) int width, height; {}
X
Xstruct hardware *NewWindowHardware (width, height) int width, height; {}
X/*
X *	NewBitmapHardware () is expected to create a new bitmap. Only one plane will be needed.
X *	
X *	NewWindowHardware () is expected to create a window on the screen. On a colour system this will
X *	be expected to support full colour.
X */
X
Xint IsWindowHardware (h) struct hardware *h; {}
X/*
X *	IsWindowHardware () should return TRUE if the hardware is a window, FALSE otherwise.
X *	NULL is a window.
X */
X
Xvoid DestroyHardware (h) struct hardware *h; {}
X/*	
X *	DestroyHardware () should release the resources required by the hardware, bitmap or window.
X *	This should cause a window device to vanish. NULL is not an error (does nothing).
X */
X
X
XMatrix DeviceMatrix (width, height) int width, height; {}
X
X/*
X *
X *	DeviceMatrix () should return a matrix appropriate to a device of the given height and width.
X *	For a typical display with a graphics origin at the top left of a window,
X *	an appropriate definition would be:
X *	
X *	Matrix DeviceMatrix (width, height) int width, height;
X *	 {
X *	 	return NewMatrix (PIXELS_PER_INCH / 72.0, 0.0, 0.0, -PIXELS_PER_INCH / 72.0, 0.0, (float) height);
X *	 }
X */
X
XDevicePoint HardwareExtent (h) struct hardware *h; {}
X/*	HardwareExtent () returns a DevicePoint describing the width and height of the argument.
X *	NULL has extent NewDevicePoint (0, 0).
X */
X
X/******************************************* OUTPUT PRIMITIVES ******************************/	
X
Xvoid BitBlt (from, to, fromPoint, toPoint, extent, rop)
X	struct hardware *from, *to;
X	DevicePoint toPoint, fromPoint, extent;
X	int rop;
X {}
X
Xvoid Paint (from, to, fromPoint, toPoint, extent, colour)
X	struct hardware *from, *to;
X	DevicePoint toPoint, fromPoint, extent;
X	Colour colour;
X {}
X
X/*	
X *	BitBlt () is a full function RasterOp. The 'rop' argument
X *	will have values as described in the header file hard.h. If the from argument is NULL it is taken to be
X *	a bitmap full of ones the shape of the fromPoint and extent. If the to argument is NULL, this is a no-op.
X *	
X *	Paint () is an addition to BitBlt. Bits that are set in the source are Painted into the destination
X *	in the given colour with a copying rasterop so that they replace pixels previously there. If the
X *	machine does not support colour windows, half-toning should be performed. 
X *	Colour values have hue, saturation and brightness components. on a black and white or greyscale
X *	system the brightness value will be a FP value between 0.0 (black) and 1.1 (white), which can be
X *	used as a grey level.
X *	
X *	Paint is expected to mask with the clip mask. BitBlt is not,
X */
X
Xvoid BitBltTrapezoid (to, lefttop, leftbottom, righttop, rightbottom, top, bottom, rop)
X	struct hardware *to;
X	DevicePoint lefttop, leftbottom, righttop, rightbottom;
X	int top, bottom, rop;
X {}
X
Xvoid PaintTrapezoid (to, lefttop, leftbottom, righttop, rightbottom, top, bottom, colour)
X	struct hardware *to;
X	DevicePoint lefttop, leftbottom, righttop, rightbottom;
X	int top, bottom;
X	Colour colour;
X {}
X
X/*
X * 	BitBltTrapezoid () and PaintTrapezoid () render a complete trapezoidal shape.
X *	The corners of the trapezoid may lie far outside the range of interesting scan-lines, but the slope
X *	of the line should be clipped by the top and bottom. The coordinates are half-open.
X */
X
Xvoid BitBltLine (h, fromPoint, toPoint, rop)
X	struct hardware *h;
X	DevicePoint fromPoint, toPoint;
X	int rop;
X {}
X
Xvoid PaintLine (h, fromPoint, toPoint, colour)
X	struct hardware *h;
X	DevicePoint fromPoint, toPoint;
X	Colour colour;
X {}
X
X/*	
X *	BitBltLine () is expected to draw a line between the given points
X *	with the given RasterOp and colour masking.
X *	The line should be one pixel wide and half-open.
X *	[Thicker lines are done with BitBlt.]
X *	
X *	PaintLine () is expected to Paint a line by analogy with Paint and BitBlt.
X */
X
Xvoid BitBltBlob (to, top, height, left, right, rop)
X	struct hardware *to;
X	int top, height, *left, *right, rop;
X {}
X
X /*
X  *	BitBltBlob () takes a set of pixel coordinates and fills the trapezon figure
X  *	half open.
X  */
X
Xvoid RasterTile (from, to, toPoint, extent, rop)
X	struct hardware *from, *to;
X	DevicePoint toPoint, extent;
X	int rop;
X {}
X
X/*
X *	RasterTile () replicates the whole of ``from'' over ``to'', but clipped by the
X *	rectangle bounded by ``toPoint'' and ``extent''.
X */
X
X/*********************************** BRIGHTNESS TRANSFER FUNCTION ************************/
X
Xint TransferSize () {}
X
Xvoid SetTransfer (vec) float *vec; {}
X/*	
X *	TransferSize () and SetTransfer () control the mapping function between user brightnesses
X *	and device brightnesses. The interface is expected to perform this mapping of brightnesses
X *	to a sufficient resolution. SetTransfer takes a table of floating point numbers between
X *	0 and 1. User brightnesses are scaled to the size of this table and mapped through it.
X *	The argument table given to SetTransfer () will be deleted after use. TransferSize () simply
X *	enquires the required size of the table.
X *	
X *	It may be appropriate to half-tone on a grayscale or colour device to improve rendering if it is not too
X *	expensive. TransferSize () returns the size of the pattern table.
X */
X
X/********************************** BITMAP CONVERSION ********************************/
X
Xchar *StringFromHardware (h) struct hardware *h; {}
X
Xstruct hardware *HardwareFromString (s, width, height) char *s; int width, height; {}
X/*	
X *	StringFromHardware () produces a string from its argument which describes the bitmap.
X *	The bitmap is returned in row-major order with the leftmost bit of each byte in the most significant
X *	position. Rows are padded to byte boundaries. Only single plane bitmaps are used.
X *	
X *	HardwareFromString () performs the inverse mapping, generating a bitmap from a set of bits, given
X *	a width and height. Only single plane bitmaps are used.
X */
X
X/************************************* HALF-TONE SCREEN ***********************************/
X
Xint ScreenSize (freq, rotation) float freq, rotation; {}
X
Xvoid BuildScreen (freq, rotation, x, y) float freq, rotation, *x, *y; {}
X
Xvoid SetScreen (freq, rotation, thresh) float freq, rotation, *thresh; {}
X/*
X *	ScreenSize () allows PostScript to determine how large an array of sample points to expect.
X *	It should return the length of the side of the sample square.
X *	
X *	BuildScreen () returns a set of sampling coordinates to PostScript to hand to the users spot-function
X *	
X *	SetScreen () allows PostScript to set the thresholds for each sample point so that half-tone bitmaps
X *	can be made.
X */
X
X/************************************* CLIPPING **********************************************/
X
Xvoid SetClipHardware (h, clip) struct hardware *h, *clip; {}
X/*	
X *	SetClipHardware sets hardware which is a clip mask for BitBlt. This mask should be ANDed with any output
X *	operation. If clip is NULL, masking will not be needed.
X */
X
X/**************************************** UPDATE CONTROLS ******************************************/
X
Xvoid HardUpdate () {}
X/*
X *	HardUpdate is a hook to allow devices which do output buffering to flush that buffering when appropriate.
X *	This allows an interactive user to see completed graphics between prompts (it is called as a side-effect
X *	of the PostScript flush operator). Typically is is a no-op.
X */
X
Xvoid UpdateControl (h, on) struct hardware *h; int on; {}
X/*
X * 	This call can be used to enable batching of output operations. UpdateControl (h, FALSE) means ``start of
X *	batching'' UpdateControl (h, TRUE) means ``end of batching''. It is used to improve performance on machines
X *	where screen updates have a high locking overhead. It may be a no-op.
X *	The operation should nest if batching is already in progress: FALSE increments a counter,
X *	TRUE decrements a counter. Display changes are allowed when the counter is non-zero.
X */
X
X/********************************** CANONICAL IMPLEMENTATION LIBRARY ******************************/
X
X/*
X *	Some parts of the above interface can be supported by a canonical library.
X *	This library contains:
X
XSetClipHardware
XHardUpdate
XIsWindowHardware
XHardwareExtent
X
XPaintTrapezoid
XBitBltTrapezoid
X
XPaint
XPaintLine
X
XDeviceMatrix
XInitTransfer
XTransferSize
XSetTransfer
XScreenSize
XBuildScreen
XSetScreen
X
X *
X *	As the driver matures, the user may provide his own versions of the canonical routines.
X *	This leaves the following for implementation by the user.
X *
X
XInitHardware
XNewBitmapHardware
XNewWindowHardware
XDestroyHardware
XHardwareFromString
XStringFromHardware
XUpdateControl
XRasterTile
XBitBlt
XBitBltLine
XBitBltBlob
X
X *	There is a pedagogical implementation in null.c
X *	
X *	There are a number of interface issues concerning the canonical driver.
X *	Firstly, a canonical struct hardware is defined, which contains a union of
X *	a char * and an int handle. The remainder are expected to use this to store
X *	device specific information.
X *
X *	InitTransfer() should be called during InitHardware with the number of pixels
X *	per inch on the display as an argument.
X */
END_OF_FILE
if test 10584 -ne `wc -c <'source/hard-interface.c'`; then
    echo shar: \"'source/hard-interface.c'\" unpacked with wrong size!
fi
# end of 'source/hard-interface.c'
fi
if test -f 'source/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/main.c'\"
else
echo shar: Extracting \"'source/main.c'\" \(10508 characters\)
sed "s/^X//" >'source/main.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include <signal.h>
X#include "main.h"
X
X#define ERRORDICTSIZE	 25
X
XObject PDictFull;
XObject PDictOverflow,		PInvFont,		PSyntaxError;
XObject PDictUnderflow,		PInvRestore,		PTypeCheck;
XObject PExecOverflow,		PIOError,		PUndefined;
XObject PExecUnderflow,		PLimitCheck,		PUnFilename;
XObject PInterrupt,		PNoCurrentPoint,	PUnResult;
XObject PInvAccess,		PRangeCheck,		PUnMatched;
XObject PInvExit,		POpOverflow,		PUnregistered;
XObject PInvFileAccess,		POpUnderflow,		PVMError;
X
XObject Lbracket, Rbracket, Nil, Marker;
XObject OpInterp, ErrorDict;
X
Xstatic int ErrorFn ();
Xstatic Object InsErr ();
Xstatic void InitErrors (), InitArguments (), Interpreter ();
Xstatic Object OpError, error_name, execName;
X
Xstatic catchint ();
Xstatic int EnableInterrupts ();
X
Xchar *library;
X
Xstatic int files_present = 0, interrupted = FALSE, protected = 0;
Xint interactive = FALSE, verbose = FALSE;
XFILE *vfp = NULL;
X
Xmain (argc, argv) int argc; char **argv;
X {
X 	char profile[BUFSIZE], rcfile [BUFSIZE], *getenv ();
X 	FILE *fp;
X 	int here;
X 	
X 	library = getenv ("POSTSCRIPTLIB");
X	if (library == NULL)
X		library = default_library;
X	
X	VOID sprintf (rcfile, "%s/psrc", library);
X 	
X 	if (close (dup (9)) == 0)
X 	 {
X 		verbose = TRUE;
X 		vfp = fdopen (9, "w");
X 	 }
X 	Message ("POSTSCRIPT");
X 	Init ();
X 	Message ("Init Errors");
X 	InitErrors ();
X	Message ("Init Arguments");
X	
X	VOID Push (ExecStack, Cvx (NameFrom ("executive")));
X	
X	here = Height (ExecStack);
X	
X	Install ("Library", StringFrom (library));
X	
X	InitArguments (argc, argv);
X	interactive = interactive || isatty (0) && !files_present;
X	ReverseStack (ExecStack, Height (ExecStack) - here);
X	
X 	VOID strcpy (profile, getenv ("HOME") ? getenv ("HOME") : "/etc");
X 	VOID strcat (profile, "/.postscript");
X 	
X 	if (fp = fopen (profile, "r"))
X		VOID Push (ExecStack, Cvx (FileFrom (fp)));
X		
X	if (!interactive)
X		VOID Push (ExecStack,
X			Cvx (StringFrom (files_present ?
X					"/executive null def" :
X					"/executive (%stdin) (r) file cvx def")));
X	
X	if ((fp = fopen (rcfile, "r")) == NULL)
X		fprintf (stderr, "%s: cannot open %s\n", argv[0], rcfile),
X		exit (1);
X	else
X		VOID Push (ExecStack, Cvx (FileFrom (fp)));
X	InstallOp ("enableinterrupts",	EnableInterrupts, 0, 0, 0, 0);
X/*	SysDict = ReadOnly (SysDict);	*/
X	Message ("Entering Interpreter");
X	Interpreter ();
X }
X
XMessage (s) char *s;
X {
X	if (vfp != NULL)
X		fprintf (vfp, "%s\n", s), fflush (vfp);
X }
X
XProtect ()
X {
X 	++protected;
X }
X
XUnprotect ()
X {
X 	--protected;
X }
X
Xstatic int EnableInterrupts ()
X {
X	if (interactive)
X		VOID signal (SIGINT, catchint);
X	return TRUE;
X }
X
Xstatic void InitArguments (argc, argv) int argc; char **argv;
X {
X  	int i, command = FALSE;
X	
X	for (i = 1; i < argc; i++)
X	 {
X	 	FILE *fp;
X	 	
X	 	if (command)
X	 	 {
X	 	 	command = FALSE;
X	 	 	VOID Push (ExecStack, Cvx (StringFrom (argv[i])));
X	 	 }
X	 	else if (*argv[i] == '-')
X	 		switch (argv[i][1])
X	 		 {
X	 		 	case 'i':
X	 		 		interactive = TRUE;
X	 		 		break;
X	 		 	
X	 		 	case 'c':
X	 		 		++files_present; 
X	 		 		command = TRUE;
X	 		 		break;
X	 		 	
X	 		 	case 's': case '\0':
X	 		 		++files_present;
X			 		VOID Push (ExecStack, Cvx (Fstdin));
X	 		 		break;
X	 		 	
X	 		 	default:
X	 		 		fprintf (stderr, "%s: unknown option '%c'\n", argv[0], argv[i][1]);
X	 		 		exit (1);
X 	 		 }
X 	 	else
X 	 	 {
X 	 	 	++files_present;
X 	 	 	if (fp = Fopen (argv[i], "r"))
X 				VOID Push (ExecStack, Cvx (FileFrom (fp)));
X 			else
X 				fprintf (stderr, "%s: cannot open %s\n", argv[0], argv[i]);
X 		 }
X 	 }
X }
X
Xstatic void Interpreter ()
X {
X	Self = execName = NameFrom ("exec");
X	while (Height (ExecStack) != 0)
X	 {
X 		int res;
X 		Object item, exop;
X 		
X 		item = Pop (ExecStack);
X  		if (!xCheck (item))
X 			res = Push (OpStack, item);
X  		else if (TypeOf (item) == Operator)
X  			res = ExecOperator (item);
X  		else if (TypeOf (item) == Array)
X  			res = ExecArray (item);
X  		else if (TypeOf (item) == File)
X  			res = ExecFile (item);
X  		else if (TypeOf (item) == Name)	/* names get special treatment for speed */
X  		 {
X  		 	Object newitem;
X  		 	
X  		 	newitem = Load (item);
X  		 	if (TypeOf (newitem) != Condition)
X  		 	 	item = newitem;
X  		 	
X  		 	if (!xCheck (item))
X 				res = Push (OpStack, item);
X  			else if (TypeOf (item) == Operator)
X  				res = ExecOperator (item);
X  			else if (TypeOf (item) == Array)
X  				res = ExecArray (item);
X  			else if (TypeOf (item) == File)
X  				res = ExecFile (item);
X			else
X  			 {
X 		 		res = Push (OpStack, item);
X  		 		exop = Lookup (TypeOf (item), execName);
X  		 		if (TypeOf (exop) != Condition)
X  		 			VOID Push (ExecStack, exop);
X  		 	 }
X   		 }
X  		else
X  		 {
X  		 	res = Push (OpStack, item);
X  		 	exop = Lookup (TypeOf (item), execName);
X  		 	if (TypeOf (exop) != Condition)
X  		 		VOID Push (ExecStack, exop);
X  		 }
X  		
X	 	if (interrupted && !protected)
X	 	 {
X 			interrupted = FALSE;
X 			error_name = PInterrupt;
X 			res = FALSE;
X 		 }
X 		
X  		if (!res)
X  		 {
X  		 	Object error_op;
X  		 	
X  		 	VOID Push (OpStack, Self);
X			error_op = DictLoad (ErrorDict, error_name);
X			if (TypeOf (error_op) == Condition)
X				VOID Push (ExecStack, OpError);
X			else
X				VOID Push (ExecStack, error_op);
X	 		Cbreak (TRUE);
X	 	 }
X	 }
X }
X
Xstatic void InitErrors ()
X {
X	ErrorDict = MakeDict (ERRORDICTSIZE);
X		PDictFull	= InsErr (ErrorDict, "dictfull",			ErrorFn);
X		PDictOverflow	= InsErr (ErrorDict, "dictstackoverflow",	ErrorFn);
X		PDictUnderflow	= InsErr (ErrorDict, "dictstackunderflow",	ErrorFn);
X		PExecOverflow	= InsErr (ErrorDict, "execstackoverflow",	ErrorFn);
X		PExecUnderflow	= InsErr (ErrorDict, "execstackunderflow",	ErrorFn);
X		PInterrupt	= InsErr (ErrorDict, "interrupt",		ErrorFn);
X		PInvAccess	= InsErr (ErrorDict, "invalidaccess",		ErrorFn);
X		PInvExit	= InsErr (ErrorDict, "invalidexit",		ErrorFn);
X		PInvFileAccess	= InsErr (ErrorDict, "invalidfileaccess",	ErrorFn);
X		PInvFont	= InsErr (ErrorDict, "invalidfont",		ErrorFn);
X		PInvRestore	= InsErr (ErrorDict, "invalidrestore",		ErrorFn);
X		PIOError	= InsErr (ErrorDict, "ioerror",			ErrorFn);
X		PLimitCheck	= InsErr (ErrorDict, "limitcheck",		ErrorFn);
X		PNoCurrentPoint	= InsErr (ErrorDict, "nocurrentpoint",		ErrorFn);
X		PRangeCheck	= InsErr (ErrorDict, "rangecheck",		ErrorFn);
X		POpOverflow	= InsErr (ErrorDict, "stackoverflow",		ErrorFn);
X		POpUnderflow	= InsErr (ErrorDict, "stackunderflow",		ErrorFn);
X		PSyntaxError	= InsErr (ErrorDict, "syntaxerror",		ErrorFn);
X		PTypeCheck	= InsErr (ErrorDict, "typecheck",		ErrorFn);
X		PUndefined	= InsErr (ErrorDict, "undefined",		ErrorFn);
X		PUnFilename	= InsErr (ErrorDict, "undefinedfilename",	ErrorFn);
X		PUnResult	= InsErr (ErrorDict, "undefinedresult",		ErrorFn);
X		PUnMatched	= InsErr (ErrorDict, "unmatchedmark",		ErrorFn);
X		PUnregistered	= InsErr (ErrorDict, "unregistered",		ErrorFn);
X		PVMError	= InsErr (ErrorDict, "VMerror",			ErrorFn);
X	Install ("errordict", ErrorDict);
X	OpError = MakeOp ("(errorfn)", ErrorFn, 1, 0, 0, 1, Name);
X }
X
X/*
X * This is the code to deal with user interrupts
X * In order to do this cleanly, we effectively poll for interrupts in the
X * main interpreter loop (above). Possibly any routine which could take an
X * inordinate amount of time out of this loop should also poll the `interrupted'
X * variable and generate an error if one is found.
X * Currently none do - "run"ning a file is done by the interpreter above.
X *
X */
X
Xstatic catchint ()
X {
X 	VOID signal (SIGINT, catchint);
X 	interrupted = TRUE;
X }
X
Xint Interrupted ()
X {
X	return interrupted && !protected;
X }
X
X/*
X *	An intrinsic operator generates an error condition by returning FALSE.
X *	The usual way to do this is to call Error with the PostScript name of
X *	the error condition.
X *	
X */
X
Xstatic Object InsErr (dict, name, fn) Object dict; char *name; int (*fn)();
X {
X 	Object op;
X 	
X 	DictStore (dict, op = NameFrom (name), MakeOp (name, fn, 1, 0, 0, 1, Name));
X 	return op;
X }
X
Xstatic ErrorFn (name) Object name;
X {
X 	PrintName (Self);
X 	printf (" in operator ");
X 	PrintName (name);
X 	putchar ('\n');
X 	return Push (ExecStack, Cvx (NameFrom ("stop")));
X }
X
Xint Error (error) Object error;
X {
X 	error_name = error;
X 	return FALSE;
X }
X
XObject MakeObject (type) Type type;
X {
X 	Object res;
X 	
X 	res.type = type;
X 	res.flags = READABLE | WRITEABLE;
X 	res.Length = res.u.Integer = 0;
X 	
X 	return res;
X }
X
Xint OpCheck (args, res) int args, res;
X {
X 	if (OpStack->stack_fill < args)
X 		return Error (POpUnderflow);
X 	else if (OpStack->stack_fill - args + res > OpStack->stack_size)
X 		return Error (POpOverflow);
X 	else
X 		return TRUE;
X }
X
XPanicIf (cond, s) int cond; char *s;
X {
X 	if (cond)
X 		Panic (s);
X }
X
XPanic (s) char *s;
X {
X	fprintf (stderr, "PostScript panic: %s\n", s);
X 	fprintf (stderr, "Please report this fault to the support person for this program\n");
X 	Cleanup ();
X 	exit (1);
X }
X
Xint min (a, b) int a, b;
X {
X 	return a < b ? a : b;
X }
X
Xint rCheck (object) Object object;
X {
X 	if (object.type == Dictionary)
X 		return object.u.Dictionary->dict_flags & READABLE;
X 	else
X 		return object.flags & READABLE;
X }
X
Xint wCheck (object) Object object;
X {
X 	if (object.type == Dictionary)
X 		return object.u.Dictionary->dict_flags & WRITEABLE;
X 	else
X 		return object.flags & WRITEABLE;
X }
X
Xint xCheck (object) Object object;
X {
X 	return object.flags & EXECUTABLE;
X }
X
XObject Cvx (o) Object o;
X {
X	o.flags |= EXECUTABLE;
X	return o;
X }
X
XObject Cvlit (o) Object o;
X {
X	o.flags &= ~EXECUTABLE;
X	return o;
X }
X
XObject ExecOnly (o) Object o;
X {
X 	if (o.type == Dictionary)
X 		o.u.Dictionary->dict_flags &= ~(READABLE | WRITEABLE);
X 	else
X 		o.flags &= ~(READABLE | WRITEABLE);
X 	return ReadOnly (o);
X }
X
XObject ReadOnly (o) Object o;
X {
X 	if (o.type == Dictionary)
X 		o.u.Dictionary->dict_flags &= ~WRITEABLE;
X 	else
X 		o.flags &= ~WRITEABLE;
X 	return o;
X }
X
XObject WriteOnly (o) Object o;
X {
X 	if (o.type == Dictionary)
X 		o.u.Dictionary->dict_flags &= ~READABLE;
X 	else
X 		o.flags &= ~READABLE;
X 	return o;
X }
X
XObject SameFlags (a, b) Object a, b;
X {
X	b.flags = a.flags;
X	return b;
X }
X
Xint Max (a, b) int a, b;
X {
X	return a > b ? a : b;
X }
X
Xint Min (a, b) int a, b;
X {
X	return a < b ? a : b;
X }
END_OF_FILE
if test 10508 -ne `wc -c <'source/main.c'`; then
    echo shar: \"'source/main.c'\" unpacked with wrong size!
fi
# end of 'source/main.c'
fi
if test -f 'source/matrix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/matrix.c'\"
else
echo shar: Extracting \"'source/matrix.c'\" \(10133 characters\)
sed "s/^X//" >'source/matrix.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X#include "graphics.h"
X
XObject AssignMatrix ();
Xextern Matrix identity;
Xstatic int PMatrix ();
Xstatic int PIdentMatrix ();
Xstatic int PDefaultMatrix ();
Xstatic int PCurrentMatrix ();
Xstatic int PSetMatrix ();
Xstatic int PTranslate ();
Xstatic int PScale ();
Xstatic int PRotate ();
Xstatic int PConcat ();
Xstatic int PConcatMatrix ();
Xstatic int PTransform ();
Xstatic int PDTransform ();
Xstatic int PITransform ();
Xstatic int PIDTransform ();
Xstatic int PInvertMatrix ();
X
XInitMatrix ()
X {
X 	InstallOp ("matrix",		PMatrix,	0, 1, 0, 0);
X 	InstallOp ("initmatrix",	PInitMatrix,	0, 0, 0, 0);
X 	InstallOp ("identmatrix",	PIdentMatrix,	1, 1, 0, 0, Array);
X 	InstallOp ("defaultmatrix",	PDefaultMatrix,	1, 1, 0, 0, Array);
X 	InstallOp ("currentmatrix",	PCurrentMatrix,	1, 1, 0, 0, Array);
X 	InstallOp ("setmatrix",		PSetMatrix,	1, 0, 0, 0, Array);
X 	InstallOp ("translate",		PTranslate,	0, 0, 0, 0);
X 	InstallOp ("scale",		PScale,		0, 0, 0, 0);
X 	InstallOp ("rotate",		PRotate,	0, 0, 0, 0);
X 	InstallOp ("concat",		PConcat,	1, 0, 0, 0, Array);
X 	InstallOp ("concatmatrix",	PConcatMatrix,	3, 1, 0, 0, Array, Array, Array);
X 	InstallOp ("transform",		PTransform,	0, 0, 0, 0);
X 	InstallOp ("dtransform",	PDTransform,	0, 0, 0, 0);
X 	InstallOp ("itransform",	PITransform,	0, 0, 0, 0);
X 	InstallOp ("idtransform",	PIDTransform,	0, 0, 0, 0);
X 	InstallOp ("invertmatrix",	PInvertMatrix,	2, 1, 0, 0, Array, Array);
X }
X
XObject MatrixFrom (m) Matrix m;
X {
X 	return AssignMatrix (MakeArray ((Object *) Malloc (6 * sizeof (Object)), 6), m);
X }
X
Xint ExtractMatrix (pm, o) Matrix *pm; Object o;
X {
X 	int i;
X 	float temp[6];
X 	
X 	for (i = 0; i < 6; i++)
X 	 {
X 	 	Object item;
X 	 	
X 	 	item = getArray (o, i);
X 	 	if (TypeOf (item) == Integer)
X 	 		temp[i] = (float) BodyInteger (item);
X 	 	else if (TypeOf (item) == Real)
X 	 		temp[i] = BodyReal (item);
X 	 	else
X 	 		return FALSE;
X 	 }
X 	
X 	*pm = NewMatrix (temp[0], temp[1], temp[2], temp[3], temp[4], temp[5]);
X 	return TRUE;
X }
X
Xstatic int PMatrix ()
X {
X	return Push (OpStack, MatrixFrom (identity));
X }
X
Xint PInitMatrix ()
X {
X 	gstate->CTM = gstate->device->default_matrix;
X 	
X 	return TRUE;
X }
X
Xstatic int PIdentMatrix (array) Object array;
X {
X 	if (lengthArray (array) != 6)
X 		return Error (PRangeCheck);
X	VOID AssignMatrix (array, identity);
X	return Push (OpStack, array);
X }
X
Xstatic int PDefaultMatrix (array) Object array;
X {
X 	if (lengthArray (array) != 6)
X 		return Error (PRangeCheck);
X	VOID AssignMatrix (array, gstate->device->default_matrix);
X	return Push (OpStack, array);
X }
X
Xstatic int PCurrentMatrix (array) Object array;
X {
X 	if (lengthArray (array) != 6)
X  		return Error (PRangeCheck);
X	VOID AssignMatrix (array, gstate->CTM);
X	return Push (OpStack, array);
X }
X
Xstatic int PSetMatrix (array) Object array;
X {
X 	if (lengthArray (array) != 6)
X   		return Error (PRangeCheck);
X 	else if (!ExtractMatrix (&gstate->CTM, array))
X    		return Error (PTypeCheck);
X	else
X		return TRUE;
X }
X
Xstatic int PTranslate ()
X {
X 	Object tx, ty, mat;
X 	float x, y;
X 	
X 	if (!OpCheck (2, 1))
X 		return FALSE;
X 	mat = Pop (OpStack);
X	if (TypeOf (mat) == Array)
X 		if (!wCheck (mat))
X 		 	return Push (OpStack, mat), Error (PInvAccess);
X 		else if (lengthArray (mat) != 6)
X 		 	return Push (OpStack, mat), Error (PRangeCheck);
X 		else
X 		 {
X 		 	ty = Pop (OpStack);
X 		 	if (TypeOf (ty) == Integer)
X 		 		y = (float) BodyInteger (ty);
X 		 	else if (TypeOf (ty) == Real)
X 		 		y = BodyReal (ty);
X 		 	else
X 		 		return Push (OpStack, ty), Push (OpStack, mat), Error (PTypeCheck);
X 		 	tx = Pop (OpStack);
X 		 	if (TypeOf (tx) == Integer)
X 		 		x = (float) BodyInteger (tx);
X 		 	else if (TypeOf (tx) == Real)
X 		 		x = BodyReal (tx);
X 		 	else
X  		 		return Push (OpStack, tx), Push (OpStack, ty), Push (OpStack, mat), Error (PTypeCheck);
X		 	
X 		 	VOID AssignMatrix (mat, NewMatrix (1.0, 0.0, 0.0, 1.0, x, y));
X 		 	
X 		 	return Push (OpStack, mat);
X 		 }
X 	else if (TypeOf (mat) == Integer)
X 		y = (float) BodyInteger (mat);
X 	else if (TypeOf (mat) == Real)
X 		y = BodyReal (mat);
X 	else
X 		return Push (OpStack, mat), Error (PTypeCheck);
X 	
X 	tx = Pop (OpStack);
X 	if (TypeOf (tx) == Integer)
X 		x = (float) BodyInteger (tx);
X 	else if (TypeOf (tx) == Real)
X 		x = BodyReal (tx);
X 	else
X 		return Push (OpStack, tx), Push (OpStack, mat), Error (PTypeCheck);
X 	gstate->CTM = Translate (gstate->CTM, x, y);
X 	return TRUE;
X }
X
Xstatic int PScale ()
X {
X 	Object tx, ty, mat;
X 	float x, y;
X 	
X 	if (!OpCheck (2, 1))
X 		return FALSE;
X 	mat = Pop (OpStack);
X	if (TypeOf (mat) == Array)
X 		if (!wCheck (mat))
X 		 	return Push (OpStack, mat), Error (PInvAccess);
X 		else if (lengthArray (mat) != 6)
X 		 	return Push (OpStack, mat), Error (PRangeCheck);
X 		else
X 		 {
X		 	ty = Pop (OpStack);
X 		 	if (TypeOf (ty) == Integer)
X 		 		y = (float) BodyInteger (ty);
X 		 	else if (TypeOf (ty) == Real)
X 		 		y = BodyReal (ty);
X 		 	else
X 		 		return Push (OpStack, ty), Push (OpStack, mat), Error (PTypeCheck);
X 		 	tx = Pop (OpStack);
X 		 	if (TypeOf (tx) == Integer)
X 		 		x = (float) BodyInteger (tx);
X 		 	else if (TypeOf (tx) == Real)
X 		 		x = BodyReal (tx);
X 		 	else
X  		 		return Push (OpStack, tx), Push (OpStack, ty), Push (OpStack, mat), Error (PTypeCheck);
X		 	
X 		 	VOID AssignMatrix (mat, NewMatrix (x, 0.0, 0.0, y, 0.0, 0.0));
X 		 	
X 		 	return Push (OpStack, mat);
X 		 }
X 	else if (TypeOf (mat) == Integer)
X 		y = (float) BodyInteger (mat);
X 	else if (TypeOf (mat) == Real)
X 		y = BodyReal (mat);
X 	else
X 		return Push (OpStack, mat), Error (PTypeCheck);
X 	
X 	tx = Pop (OpStack);
X 	if (TypeOf (tx) == Integer)
X 		x = (float) BodyInteger (tx);
X 	else if (TypeOf (tx) == Real)
X 		x = BodyReal (tx);
X 	else
X 		return Push (OpStack, tx), Push (OpStack, mat), Error (PTypeCheck);
X 	gstate->CTM = Scale (gstate->CTM, x, y);
X 	return TRUE;
X }
X
Xstatic int PRotate ()
X {
X 	Object ang, mat;
X 	float a;
X 	
X 	if (!OpCheck (1, 1))
X 		return FALSE;
X 	mat = Pop (OpStack);
X	if (TypeOf (mat) == Array)
X 		if (!wCheck (mat))
X 		 	return Push (OpStack, mat), Error (PInvAccess);
X 		else if (lengthArray (mat) != 6)
X 		 	return Push (OpStack, mat), Error (PRangeCheck);
X 		else
X 		 {
X		 	ang = Pop (OpStack);
X 		 	if (TypeOf (ang) == Integer)
X 		 		a = (float) BodyInteger (ang);
X 		 	else if (TypeOf (ang) == Real)
X 		 		a = BodyReal (ang);
X 		 	else
X 		 		return Push (OpStack, ang), Push (OpStack, mat), Error (PTypeCheck);
X 		 	
X 		 	VOID AssignMatrix (mat, NewMatrix (cos(a), sin(a), -sin(a), -cos(a), 0.0, 0.0));
X 		 	
X 		 	return Push (OpStack, mat);
X 		 }
X 	else if (TypeOf (mat) == Integer)
X 		a = (float) BodyInteger (mat);
X 	else if (TypeOf (mat) == Real)
X 		a = BodyReal (mat);
X 	else
X 		return Push (OpStack, mat), Error (PTypeCheck);
X 	
X 	gstate->CTM = Rotate (gstate->CTM, Rad (a));
X 	return TRUE;
X }
X
Xstatic int PConcat (mat) Object mat;
X {
X 	Matrix m;
X 	
X 	if (!ExtractMatrix (&m, mat))
X 		return Error (PTypeCheck);
X 	gstate->CTM = MatMult (m, gstate->CTM);
X 	return TRUE;
X }
X
Xstatic int PConcatMatrix (mat1, mat2, mat3) Object mat1, mat2, mat3;
X {
X 	Matrix m1, m2;
X 	
X 	if (!ExtractMatrix (&m1, mat1) || !ExtractMatrix (&m2, mat2) ||
X 			lengthArray (mat3) != 6)
X 		return Error (PTypeCheck);
X 	VOID AssignMatrix (mat3, MatMult (m1, m2));
X 	VOID Push (OpStack, mat3);
X 	return TRUE;
X }
X
Xstatic int Transfn (fn) Vector (*fn)();
X {
X 	Matrix m;
X 	Object tx, ty, mat;
X 	Vector v;
X 	float x, y;
X 	int mflag = FALSE;
X 	
X 	m = gstate->CTM;
X	if (!OpCheck (2, 1))
X 		return FALSE;
X 	
X 	mat = Pop (OpStack);
X	if (TypeOf (mat) == Array)
X	 {
X 		if (lengthArray (mat) != 6 || !ExtractMatrix (&m, mat))
X 		 	return Push (OpStack, mat), Error (PTypeCheck);
X 		mflag = TRUE;
X 	 }
X	else
X 		VOID Push (OpStack, mat);
X	
X	if (!OpCheck (2, 1))
X 		return Push (OpStack, mat), FALSE;
X 	ty = Pop (OpStack);
X	if (TypeOf (ty) == Integer)
X		y = (float) BodyInteger (ty);
X	else if (TypeOf (ty) == Real)
X		y = BodyReal (ty);
X	else
X	 {
X	 	VOID Push (OpStack, ty);
X	 	if (mflag)
X			VOID Push (OpStack, mat);
X		return Error (PTypeCheck);
X	 }
X	tx = Pop (OpStack);
X 	if (TypeOf (tx) == Integer)
X 		x = (float) BodyInteger (tx);
X 	else if (TypeOf (tx) == Real)
X 		x = BodyReal (tx);
X 	else
X	 {
X	 	VOID Push (OpStack, tx);
X	 	VOID Push (OpStack, ty);
X	 	if (mflag)
X			VOID Push (OpStack, mat);
X		return Error (PTypeCheck);
X	 }
X	
X	v = (*fn) (NewVector (x, y, 1.0), m);
X	 	
X	return Push (OpStack, MakeReal (v.vx)), Push (OpStack, MakeReal (v.vy));
X }
X
Xstatic int PTransform ()
X {
X 	return Transfn (Transform);
X }
X
Xstatic int PDTransform ()
X {
X 	return Transfn (DTransform);
X }
X
Xstatic int PITransform ()
X {
X 	return Transfn (ITransform);
X }
X
Xstatic int PIDTransform ()
X {
X 	return Transfn (IDTransform);
X }
X
Xstatic int PInvertMatrix (mat1, mat2) Object mat1, mat2;
X {
X 	Matrix m;
X 	
X 	if (!ExtractMatrix (&m, mat1) || lengthArray (mat2) != 6)
X 		return Error (PTypeCheck);
X 	VOID AssignMatrix (mat2, MatInvert (m));
X 	VOID Push (OpStack, mat2);
X 	return TRUE;
X }
X
XPoint IntToExt (p) HardPoint p;
X {
X 	Vector v;
X 	
X 	v = Transform (NewVector ((float) p.hx, (float) p.hy, 1.0), MatInvert (gstate->CTM));
X 	return NewPoint (v.vx, v.vy);
X }
X
XHardPoint ExtToInt (p) Point p;
X {
X	Vector v;
X	
X	v = Transform (NewVector (p.x, p.y, 1.0), gstate->CTM);
X	return NewHardPoint (v.vx, v.vy);
X }
X
XMatrix PointTranslate (m, p) Matrix m; Point p;
X {
X 	return Translate (m, p.x, p.y);
X }
X
XMatrix HardPointTranslate (m, p) Matrix m; HardPoint p;
X {
X 	m.tx += p.hx;
X 	m.ty += p.hy;
X 	
X 	return m;
X }
X
XObject AssignMatrix (o, m) Object o; Matrix m;
X {
X 	Object *vec = BodyArray (o);
X 	
X 	vec[0] = MakeReal (m.A);
X 	vec[1] = MakeReal (m.B);
X 	vec[2] = MakeReal (m.C);
X 	vec[3] = MakeReal (m.D);
X 	vec[4] = MakeReal (m.tx);
X 	vec[5] = MakeReal (m.ty);
X 	
X 	return o;
X }
END_OF_FILE
if test 10133 -ne `wc -c <'source/matrix.c'`; then
    echo shar: \"'source/matrix.c'\" unpacked with wrong size!
fi
# end of 'source/matrix.c'
fi
if test -f 'source/path.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'source/path.c'\"
else
echo shar: Extracting \"'source/path.c'\" \(10211 characters\)
sed "s/^X//" >'source/path.c' <<'END_OF_FILE'
X/*
X * Copyright (C) Rutherford Appleton Laboratory 1987
X * 
X * This source may be copied, distributed, altered or used, but not sold for profit
X * or incorporated into a product except under licence from the author.
X * It is not in the public domain.
X * This notice should remain in the source unaltered, and any changes to the source
X * made by persons other than the author should be marked as such.
X * 
X *	Crispin Goswell @ Rutherford Appleton Laboratory caag@uk.ac.rl.vd
X */
X#include "main.h"
X
X#include "graphics.h"
X
X#define PATHFORALLDEPTH 500
X	
Xstatic int PCurrentPoint ();
Xstatic int PMoveTo ();
Xstatic int PRMoveTo ();
Xstatic int PLineTo ();
Xstatic int PRLineTo ();
Xstatic int PArc ();
Xstatic int PArcN ();
Xstatic int PArcTo ();
Xstatic int PCurveTo ();
Xstatic int PRCurveTo ();
Xstatic int PClosePath ();
Xstatic int PPathBBox ();
Xstatic int PReversePath ();
Xstatic int PPathForAll ();
X
Xstatic int PathForAll ();
Xstatic int PPathProc ();
X
Xint PFlattenPath ();
X
XObject OpPathForAll;
X
XInitPath ()
X {
X 	OpPathForAll = MakeOp ("(oppathforall)", PathForAll, 0, 6, 7, 7);
X 	
X 	InstallOp ("newpath",		PNewPath,	0, 0, 0, 0);
X 	InstallOp ("currentpoint",	PCurrentPoint,	0, 2, 0, 0);
X  	InstallOp ("moveto",		PMoveTo,	2, 0, 0, 0, Float, Float);
X	InstallOp ("rmoveto",		PRMoveTo,	2, 0, 0, 0, Float, Float);
X 	InstallOp ("lineto",		PLineTo,	2, 0, 0, 0, Float, Float);
X 	InstallOp ("rlineto",		PRLineTo,	2, 0, 0, 0, Float, Float);
X 	InstallOp ("arc",		PArc,		5, 0, 0, 0, Float, Float, Float, Float, Float);
X 	InstallOp ("arcn",		PArcN,		5, 0, 0, 0, Float, Float, Float, Float, Float);
X 	InstallOp ("arcto",		PArcTo,		5, 4, 0, 0, Float, Float, Float, Float, Float);
X 	InstallOp ("curveto",		PCurveTo,	6, 0, 0, 0, Float, Float, Float, Float, Float, Float);
X 	InstallOp ("rcurveto",		PRCurveTo,	6, 0, 0, 0, Float, Float, Float, Float, Float, Float);
X 	InstallOp ("closepath",		PClosePath,	0, 0, 0, 0);
X 	InstallOp ("pathbbox",		PPathBBox,	0, 4, 0, 0);
X 	InstallOp ("flattenpath",	PFlattenPath,	0, 0, 0, 0);
X 	InstallOp ("reversepath",	PReversePath,	0, 0, 0, 0);
X 	InstallOp ("pathforall",	PPathForAll,	4, 0, 0, 6, Array, Array, Array, Array);
X 	InstallOp ("pathproc",		PPathProc,	0, 1, 0, 0);
X	gstate->path = NewPath ();
X	gstate->clip = NewPath ();
X }
X
Xint PNewPath ()
X {
X 	gstate->cp_defined = FALSE;
X 	PathFree (gstate->path);
X 	gstate->path = NewPath ();
X 	return TRUE;
X }
X
Xstatic int PCurrentPoint ()
X {
X 	Point cp;
X 	
X	if (!gstate->cp_defined)
X 		return Error (PNoCurrentPoint);
X 	cp = IntToExt (gstate->cp);
X 	VOID Push (OpStack, MakeReal (PointX (cp)));
X 	VOID Push (OpStack, MakeReal (PointY (cp)));
X 	return TRUE;
X }
X
Xstatic int PMoveTo (x, y) Object x, y;
X {
X 	return MoveTo (gstate->path, ExtToInt (NewPoint (BodyReal (x), BodyReal (y))));
X }
X
Xstatic int PRMoveTo (x, y) Object x, y;
X {
X	if (!gstate->cp_defined)
X 		return Error (PNoCurrentPoint);
X 	return MoveTo (gstate->path, ExtToInt (MovePoint (NewPoint (BodyReal (x), BodyReal (y)), IntToExt (gstate->cp))));
X }
X
Xstatic int PLineTo (x, y) Object x, y;
X {
X	if (!gstate->cp_defined)
X 		return Error (PNoCurrentPoint);
X	return LineTo (gstate->path, ExtToInt (NewPoint (BodyReal (x), BodyReal (y))));
X }
X
X
Xstatic int PRLineTo (x, y) Object x, y;
X {
X	if (!gstate->cp_defined)
X 		return Error (PNoCurrentPoint);
X 	return LineTo (gstate->path, ExtToInt (MovePoint (NewPoint (BodyReal (x), BodyReal (y)), IntToExt (gstate->cp))));
X }
X
Xstatic int PArc (x, y, rad, ang1, ang2) Object x, y, rad, ang1, ang2;
X {
X 	Point centre, start;
X 	float a1 = Rad (BodyReal (ang1)), a2 = Rad (BodyReal (ang2));
X 	float r = BodyReal (rad);
X 	
X 	start = NewPoint (cos (a1) * r, sin (a1) * r);
X 	centre = NewPoint (BodyReal (x), BodyReal (y));
X 	if (!(*(EmptyPath (gstate->path) ? MoveTo : LineTo)) (gstate->path, ExtToInt (MovePoint (centre, start))))
X		return FALSE;
X 	return Arc (gstate->path, 1, centre, r, a1, a2);
X }
X
Xstatic int PArcN (x, y, rad, ang1, ang2) Object x, y, rad, ang1, ang2;
X {
X 	Point centre, start;
X 	float a1 = Rad (BodyReal (ang1)), a2 = Rad (BodyReal (ang2));
X 	float r = BodyReal (rad);
X 	
X 	start = NewPoint (cos (a1) * r, sin (a1) * r);
X 	centre = NewPoint (BodyReal (x), BodyReal (y));
X 	if (!(*(EmptyPath (gstate->path) ? MoveTo : LineTo)) (gstate->path, ExtToInt (MovePoint (centre, start))))
X		return FALSE;
X 	return Arc (gstate->path, -1, centre, r, a1, a2);
X }
X
Xstatic int PArcTo (X1, Y1, X2, Y2, rad) Object X1, Y1, X2, Y2, rad;
X {
X 	float xt1, xt2, yt1, yt2;
X 	if (!gstate->cp_defined)
X 		return Error (PNoCurrentPoint);
X 	
X	return ArcTo (gstate->path, gstate->cp,
X			BodyReal (X1), BodyReal (Y1), BodyReal (X2), BodyReal (Y2), BodyReal (rad),
X 			&xt1, &yt1, &xt2,  &yt2) &&
X 		Push (OpStack, MakeReal (xt1)) &&
X		Push (OpStack, MakeReal (yt1)) &&
X		Push (OpStack, MakeReal (xt2)) &&
X		Push (OpStack, MakeReal (yt2));
X }
X
Xstatic int PCurveTo (x0, y0, x1, y1, x2, y2) Object x0, y0, x1, y1, x2, y2;
X {
X	if (!gstate->cp_defined)
X 		return Error (PNoCurrentPoint);
X 	return CurveTo (gstate->path,
X 			ExtToInt (NewPoint (BodyReal (x0), BodyReal (y0))),
X 			ExtToInt (NewPoint (BodyReal (x1), BodyReal (y1))),
X 			ExtToInt (NewPoint (BodyReal (x2), BodyReal (y2))));
X }
X
Xstatic int PRCurveTo (x0, y0, x1, y1, x2, y2) Object x0, y0, x1, y1, x2, y2;
X {
X 	Point cp;
X 	
X	if (!gstate->cp_defined)
X 		return Error (PNoCurrentPoint);
X 	cp = IntToExt (gstate->cp);
X 	return CurveTo (gstate->path,
X 			ExtToInt (MovePoint (cp, NewPoint (BodyReal (x0), BodyReal (y0)))),
X 			ExtToInt (MovePoint (cp, NewPoint (BodyReal (x1), BodyReal (y1)))),
X 			ExtToInt (MovePoint (cp, NewPoint (BodyReal (x2), BodyReal (y2)))));
X }
X
Xstatic int PClosePath ()
X {
X 	return ClosePath (gstate->path);
X }
X
Xint PFlattenPath ()
X {
X 	Path res;
X 	
X 	if ((res = FlattenPath (gstate->path)) == NULL)
X 		return Error (PLimitCheck);
X 	SetPath (&gstate->path, res);
X	return TRUE;
X }
X
Xstatic int PReversePath ()
X {
X	Path res;
X 	
X 	if ((res = ReversePath (gstate->path)) == NULL)
X 		return Error (PLimitCheck);
X  	SetPath (&gstate->path, res);
X 	return TRUE;	
X }
X
Xstatic Path pathforall [PATHFORALLDEPTH], *pathp = pathforall;
Xstatic int path_depth = 0;
X
Xstatic int PPathForAll (move, line, curve, close) Object move, line, curve, close;
X {
X 	Path res;
X 	
X 	if ((res = PathCopy (gstate->path)) == NULL || path_depth == PATHFORALLDEPTH - 1)
X 		return Error (PLimitCheck);
X 	*++pathp = res;
X 	++path_depth;
X 	VOID Push (ExecStack, Nil);
X 	VOID Push (ExecStack, move);
X 	VOID Push (ExecStack, line);
X 	VOID Push (ExecStack, curve);
X 	VOID Push (ExecStack, close);
X 	VOID Push (ExecStack, OpPathForAll);
X 	return TRUE;
X }
X
Xstatic int PathForAll ()
X {
X 	Path res;
X 	Object move, line, curve, close, fn;
X 	Point p;
X 	
X 	close = Pop (ExecStack);
X 	curve = Pop (ExecStack);
X 	line = Pop (ExecStack);
X 	move = Pop (ExecStack);
X 	if (EmptyPath (*pathp))
X 	 {
X 	 	PathFree (*pathp--);
X 	 	--path_depth;
X 	 	VOID Pop (ExecStack);
X 		return TRUE;
X 	 }
X 	res = (*pathp)->next;
X 	switch (res->ptype)
X 	 {
X 	 	case EMove:
X 	 		p = IntToExt (res->pe.point);
X 	 		VOID Push (OpStack, MakeReal (p.x));
X 	 		VOID Push (OpStack, MakeReal (p.y));
X 	 		fn = move;
X 	 		break;
X 	 	
X 	 	case ELine:
X  	 		p = IntToExt (res->pe.point);
X 	 		VOID Push (OpStack, MakeReal (p.x));
X 	 		VOID Push (OpStack, MakeReal (p.y));
X 	 		fn = line;
X 	 		break;
X 	 	
X	 	case ECurve:
X	 		p = IntToExt (res->pe.curve.x0);
X 	 		VOID Push (OpStack, MakeReal (p.x));
X 	 		VOID Push (OpStack, MakeReal (p.y));
X	 		p = IntToExt (res->pe.curve.x1);
X 	 		VOID Push (OpStack, MakeReal (p.x));
X 	 		VOID Push (OpStack, MakeReal (p.y));
X	 		p = IntToExt (res->pe.curve.x2);
X 	 		VOID Push (OpStack, MakeReal (p.x));
X 	 		VOID Push (OpStack, MakeReal (p.y));
X	 		fn = curve;
X	 		break;
X	 	
X	 	case EClose:
X	 		fn = close;
X	 		break;
X	 	
X	 	default:
X	 		Panic ("OpPathForAll - encounters unknown path element");
X	 }
X	VOID Push (ExecStack, move);
X	VOID Push (ExecStack, line);
X	VOID Push (ExecStack, curve);
X	VOID Push (ExecStack, close);
X	VOID Push (ExecStack, OpPathForAll);
X	VOID Push (ExecStack, fn);
X	
X	PathDelete (res->next);
X	return TRUE;
X }
X
Xstatic int PPathProc ()
X {
X 	Object *body, *p;
X 	int sum = 0;
X 	Path pa;
X 	Point po;
X 	
X 	for (pa = gstate->path->next; pa != gstate->path; pa = pa->next)
X 		switch (pa->ptype)
X 		 {
X 		 	case EMove: case ELine: sum += 3; break;
X 		 	case ECurve: sum += 7; break;
X 		 	case EClose: ++sum; break;
X 		 }
X 	
X	p = body = (Object *) Malloc ((unsigned) sizeof (Object) * sum);
X 	for (pa = gstate->path->next; pa != gstate->path; pa = pa->next)
X 		switch (pa->ptype)
X 		 {
X 		 	case EMove:
X 		 		po = IntToExt (pa->pe.point);
X  		 		*p++ = MakeReal (po.x);
X 		 		*p++ = MakeReal (po.y);
X  		 		*p++ = Cvx (NameFrom ("moveto"));
X		 		break;
X 		 	
X		 	case ELine:
X		 		po = IntToExt (pa->pe.point);
X  		 		*p++ = MakeReal (po.x);
X 		 		*p++ = MakeReal (po.y);
X  		 		*p++ = Cvx (NameFrom ("lineto"));
X		 		break;
X 		 	
X 		 	case ECurve:
X 		 		po = IntToExt (pa->pe.curve.x0);
X  		 		*p++ = MakeReal (po.x);
X 		 		*p++ = MakeReal (po.y);
X 		 		po = IntToExt (pa->pe.curve.x1);
X  		 		*p++ = MakeReal (po.x);
X 		 		*p++ = MakeReal (po.y);
X		 		po = IntToExt (pa->pe.curve.x2);
X  		 		*p++ = MakeReal (po.x);
X 		 		*p++ = MakeReal (po.y);
X		 		*p++ = Cvx (NameFrom ("curve"));
X		 		break;
X 		 	
X 		 	case EClose:
X 		 		*p++ = Cvx (NameFrom ("closepath"));
X 		 		break;
X 		 }
X 	return Push (OpStack, Cvx (MakeArray (body, sum)));
X }
X
Xstatic int PPathBBox ()
X {
X 	Point right_top, left_bottom, left_top, right_bottom;
X 	float left, right, top, bottom, uleft, uright, utop, ubottom;
X 	
X 	if (!PathBBox (&left, &right, &top, &bottom))
X 		return FALSE;
X 	
X 	left_bottom	= IntToExt (NewHardPoint (left, bottom));
X 	right_bottom	= IntToExt (NewHardPoint (right, bottom));
X 	right_top 	= IntToExt (NewHardPoint (right, top));
X 	left_top	= IntToExt (NewHardPoint (left, top));
X 	
X 	uleft = uright = left_bottom.x; utop = ubottom = left_bottom.y;
X 	UserBound (&uleft, &uright, &utop, &ubottom, left_top);
X 	UserBound (&uleft, &uright, &utop, &ubottom, right_top);
X 	UserBound (&uleft, &uright, &utop, &ubottom, right_bottom);
X 	
X 	VOID Push (OpStack, MakeReal (uleft));
X  	VOID Push (OpStack, MakeReal (ubottom));
X 	VOID Push (OpStack, MakeReal (uright));
X	VOID Push (OpStack, MakeReal (utop));
X 	
X	return TRUE;
X }
END_OF_FILE
if test 10211 -ne `wc -c <'source/path.c'`; then
    echo shar: \"'source/path.c'\" unpacked with wrong size!
fi
# end of 'source/path.c'
fi
echo shar: End of archive 8 \(of 18\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

